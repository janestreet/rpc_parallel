#+TITLE: Rpc\_parallel

=Rpc_parallel= is a library that uses processes to achieve
parallelism. Because of the garbage collector and async locks,
thread-level parallelism in OCaml is not achievable.

The library works by spawning processes that start rpc servers. The
spawned process is running /proc/self/exe (i.e. the same executable as
the running process). Communication between a "master" and a "worker"
involves sending rpc queries and receiving rpc responses. The "worker"
already has the code to do computation because it is running the same
binary!

* Mental Model

- =Worker.t= identifies a worker rpc server
- =spawn= (=serve=) starts a worker rpc server in another process (the same
  process)
- =client= connects to a worker rpc server
- =run= dispatches on a connection to a worker rpc server

* Top-level

It is highly recommended for =Rpc_parallel.start_app= and =Rpc_parallel.Make=
calls to be top-level. But the real requirements are:

1) The master's state is initialized before any calls to =spawn=. This will be
   achieved either by =Rpc_parallel.start_app= or
   =Rpc_parallel.Expert.start_master_server_exn=.

2) Spawned workers (runs of your executable with a certain environment variable
   set) must start running as a worker. This will be achieved either by
   =Rpc_parallel.start_app= or =Rpc_parallel.Expert.worker_command=.

3) Spawned workers must be able to find their function implementations when they
   start running as a worker. These implementations are gathered on the
   application of the =Rpc_parallel.Make= functor.

4) The worker implementations must be defined completely and in the same order,
   regardless of master and worker code paths. This is necessary for the masters
   and workers to agree on certain generated ids.

* Monitoring your workers

Uncaught exceptions in workers will always result in the worker
calling =Shutdown.shutdown=. The master can be notified of these
exceptions in multiple ways:

- If the exception occured in a function implementation =f= before =f= is
  determined, the exception will be returned back to the caller. E.g. the caller
  of =spawn= or =run= will get an =Error.t= describing the exception.

- If the exception occured after =f= is determined, =on_failure exn= will be
  called (in =Monitor.current ()= at the time of =spawn=) in the spawning
  process.

- If =redirect_stderr= specifies a file, the worker will also write its
  exception to that file before shutting down.

* Dealing with long async cycles

Long async cycles can cause the connections to your workers to close.
If you are using =~shutdown_on:Disconnect= (which is recommended!),
then this connection closing will result in your worker shutting down.

You can bump the =max_message_size=, =heartbeat_config=, and
=handshake_timeout= settings that are used for all rpc communication.
These settings are determined by (in descending order of preference):

1) The environment variable =RPC_PARALLEL_RPC_SETTINGS= (see
   =Rpc_settings= in =lib/rpc_parallel/src/parallel.ml= for how to
   construct a value)
2) Arguments supplied to =start_app= or =Expert.start_master_server_exn=
3) The defaults supplied by the =Rpc= library
